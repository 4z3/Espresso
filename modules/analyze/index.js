
// module: analyze

JSLINT = require('../../lib/jslint').JSLINT;

exports.deps = [ 'config', 'scripts' ];
exports.revdep = [ 'cache.manifest' ];

exports.duty = function (callback) {
  var scripts = this.scripts;
  var self = this.self;
  var config = this.config;

  scripts.forEach(function (file) {
    var analysis = file.analysis = {
      definitions: {},
      references: {}
    };

    var result = JSLINT(file.content.toString()); // TODO check result?

    var T = deep_copy(JSLINT.tree); // TODO store ast in analysis?

    var the_relevant_parts = ['M', 'm_require', self.name]; // TODO config
    if (config.reachable instanceof Array) {
      config.reachable.forEach(function (name) {
          if (the_relevant_parts.indexOf(name) < 0) {
            the_relevant_parts.push(name);
          };
        });
    };

    // collect <M-REF> X.y
    walk(T,
        function (T) {
          return (T.value === '.' &&
                  T.arity === 'infix' &&
                  Object.keys(T.first).length === 1 && 'value' in T.first &&
                  the_relevant_parts.indexOf(T.first.value) >= 0 &&
                  Object.keys(T.second).length === 1 && 'value' in T.second);
        },
        function (T) {
          T.ref = [T.first.value, T.second.value].join('.');
          T.value = '<M-REF>';
          analysis.references[T.ref] = true;
        });                      
    // collect <M-REF> X
    walk(T,
        function (T) {
          return (Object.keys(T).length === 1 && 'value' in T &&
                  the_relevant_parts.indexOf(T.value) >= 0);
        },
        function (T) {
          T.ref = T.value;
          T.value = '<M-REF>';
          analysis.references[T.ref] = true;
        });
    // collect <M-DEF> 
    walk(T,
        function (T) {
          return (T.value === '=' &&
                  T.arity === 'infix' &&
                  T.first.value === '<M-REF>');
        },
        function (T) {
          T.def = T.first.ref;
          T.value = '<M-DEF>';
          analysis.definitions[T.def] = true;
        });

    analysis.references = Object.keys(analysis.references);
    analysis.definitions = Object.keys(analysis.definitions);

    console.log(file.requestPath, ':', 'analyzed');
  });

  callback();
};

/**
 * Properties of the AST generated by JSLint, that should be recognized by
 * {@link deep_copy} and {@link walk}.
 */
The_relevant_parts = [
  'value',  'arity', 'name',  'first',
  'second', 'third', 'block', 'else'
];

/**
 * Copy a tree.  Only {@link The_relevant_parts} get copied.
 * @param {tree}
 * @returns {tree} fresh copy of the tree
 */
function deep_copy(T) {
  return JSON.parse(JSON.stringify(T, The_relevant_parts));
};

/**
 * Walk a tree and execute a function whenever the predicate returns true.
 * The function can be used to modify the tree (in place).
 * 
 * @param {tree}
 * @param {predicate}
 * @param {function}
 */
function walk(T, p, f) {
  if (typeof T === 'object') {
    if (T instanceof Array) {
      T.forEach(function (T) {
        walk(T, p, f);
      });
    } else if (p(T)) {
      f(T);
    } else {
      walk_children(T, p, f);
    };
  };
};

function walk_children(T, p, f) {
  The_relevant_parts.forEach(function (part) {
    walk(T[part], p, f);
  });
};

